<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[负载均衡算法]]></title>
    <url>%2F2020%2F04%2F21%2F%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[负载均衡算法&#160; &#160; &#160; &#160;负载均衡算法，一般在分布式场景的中大量使用，负载均衡一般分为调用方负载均衡，和服务方负载均衡，spring cloud中的ribbon就是使用的调用方负载均衡，而通过nginx的配置来进行负载均衡，明显更像是服务端的负载均衡。但是原理是一致的，算法的目的就是在一个服务器集合中，选择其中一个合适的服务器，进行请求的处理。&#160; &#160; &#160; &#160;常见的负载均衡算法包括：随机，轮询，最小压力，哈希。主要为这几大类，其中各自有如带权重的实现，一致性哈希等更好的算法。&#160; &#160; &#160; &#160;这篇文章起源于接手了公司的另一个组的一个cloud项目，是一个架构搭的，所以仔细看了一遍，看到了基于ribbon的带权重轮询算法实现，一开始看了好久不知道在干什么，补充了相关知识后豁然开朗，于是对这2种算法做一个总结和记录，本文主要描述带权重的轮询算法以及平滑的带权重轮询算法的原理以及实现。 带权重的轮询负载均衡算法&#160; &#160; &#160; &#160;轮询负载均衡即在所有服务之间，依次选择每个服务，若服务器有A、B、C、D、E，则调度顺序必定为A、B、C、D、E、A、B、C、D……的循环。带权重的轮询即为在轮询的基础上，考虑每个服务的权重，如服务器A、B、C、D、E对应权重{5,1,1,1,1}，一般来说在某总权重(5+1+1+1+1)=9次调度内调度顺序就为AAAAABCDE。&#160; &#160; &#160; &#160;该算法可以很简单的实现，只需要每次选取后将权重-1，直到总权重为0，重置权重数组，即可完成处理。代码如下 12345678910111213141516171819202122232425262728293031323334353637func doSimpleWeightBound(servers []Server,initWeight []int)&#123; res:=list.New() weight:=make([]int,len(initWeight)) count:=make([]int, len(weight)) totalWeight:=0 for i := 0; i&lt; len(initWeight);i++ &#123; totalWeight+=initWeight[i] &#125; copy(weight,initWeight) nowWeight:=totalWeight //一共做totalWeight*100次，查看结果。 for i := 0; i &lt; totalWeight*100; i++ &#123; //1. 选出当前权重最高的机器 position:=selectHighWeight(weight) count[position]++ res.PushBack(servers[position].name) //2. 选出的机器权重数减1 weight[position]-- //3. 总权重减1 nowWeight-- if(nowWeight&lt;=0)&#123; copy(weight,initWeight) nowWeight=totalWeight &#125; &#125; for i :=0; i &lt; len(weight); i ++ &#123; fmt.Printf("%d ",weight[i]) &#125; fmt.Println() for i := res.Front(); i != nil; i = i.Next() &#123; fmt.Printf("%s ",i.Value) &#125; fmt.Println() for i :=0; i &lt; len(count); i ++ &#123; fmt.Printf("%s: %d\n",string('A'+i),count[i]) &#125;&#125; &#160; &#160; &#160; &#160;代码执行结果如下：可以看到，执行结果在带权综合次数内，分布为AAAAABCDE。 平滑带权重的轮询负载均衡算法&#160; &#160; &#160; &#160;带权重的轮询负载均衡算法存在一个问题，即在权重相差很大时，连续的调用在A机器上过于频繁，即使带权重的目的本身就是让权重大的机器处理更多请求，但显然让连续的调用更加平均分散在各台机器上更好。&#160; &#160; &#160; &#160;该算法的实现参照nginx开发者提供的思路，进行如下步骤： 建立两个数组，initWeight记录初始各机器的权重，weight记录过程中的权重。 求得初始总权重totalWeight。 从各机器中选出当前权重weight最高的一台机器S1。 S1对应的当前权重减去总权重totalWeight。 每台机器的当前权重weight[i]依次增加各机器初始的权重initWeight[i] 重复3-5步骤。12345678910111213141516171819202122232425262728293031323334func doSmoothlyWeightBound(servers []Server,initWeight []int)&#123; //一共做30次，分别看选出的是哪台机器。 res:=list.New() weight:=make([]int,len(initWeight)) count:=make([]int, len(weight)) totalWeight:=0 for i := 0; i&lt; len(initWeight);i++ &#123; totalWeight+=initWeight[i] &#125; copy(weight,initWeight) for i := 0; i &lt; totalWeight*8; i++ &#123; //1. 选出当前权重最高的机器 position:=selectHighWeight(weight) count[position]++ res.PushBack(servers[position].name) //2. 选出的机器减去总权重 weight[position]-=totalWeight //3. 对每台机器，增加初始权重 for j := 0; j &lt; len(weight); j++ &#123; weight[j]+=initWeight[j] &#125; &#125; for i :=0; i &lt; len(weight); i ++ &#123; fmt.Printf("%d ",weight[i]) &#125; fmt.Println() for i := res.Front(); i != nil; i = i.Next() &#123; fmt.Printf("%s ",i.Value) &#125; fmt.Println() for i :=0; i &lt; len(count); i ++ &#123; fmt.Printf("%s: %d\n",string('A'+i),count[i]) &#125;&#125; &#160; &#160; &#160; &#160;代码执行结果如下：&#160; &#160; &#160; &#160;可以看到，执行结果在带权综合次数内，总次数满足权重比例，且顺序不再是纯粹的连续顺序。 缺点&#160; &#160; &#160; &#160;该算法的缺点也很明显，每次总权重周期内的顺序必定是相同的，实际上在服务与权重不变的情况下，只要生成一次顺序，以后就按照顺序去轮询即可，不需要维护计算。 思考如何在服务列表变化的情况下，执行算法？&#160; &#160; &#160; &#160;以上算法的实现非常明显的只考虑到了在服务列表以及权重不变的情况下，进行多次选择。但是如果感知到服务列表或者权重比例变化的情况下，该如何处理呢？&#160; &#160; &#160; &#160;通过过程可以发现，算法主要依赖的就是初始权重以及服务列表，在感知到服务列表变化时，应通过一些同步机制，及时的更新正在进行选择时的服务列表以及权重比例，及时重新计算相关数组以及总权重数。具体可容忍什么程度的一致性，就用什么同步方式去更新。 总结&#160; &#160; &#160; &#160;通过看高手的代码以及实现，深入了解了一部分知识点。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>分布式</tag>
        <tag>spring cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题录-1395]]></title>
    <url>%2F2020%2F04%2F01%2Fleetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-1395%2F</url>
    <content type="text"><![CDATA[题目题目地址：https://leetcode-cn.com/problems/count-number-of-teams/&#160; &#160; &#160; &#160; n 名士兵站成一排。每个士兵都有一个 独一无二 的评分 rating 。每 3 个士兵可以组成一个作战单位，分组规则如下：从队伍中选出下标分别为 i、j、k 的 3 名士兵，他们的评分分别为 rating[i]、rating[j]、rating[k]作战单位需满足： rating[i] &lt; rating[j] &lt; rating[k] 或者 rating[i] &gt; rating[j] &gt; rating[k] ，其中 0 &lt;= i &lt; j &lt; k &lt; n请你返回按上述条件可以组建的作战单位数量。每个士兵都可以是多个作战单位的一部分。 思考过程&#160; &#160; &#160; &#160;这个题目乍一看，就觉得像是贪心或者是DP，最近做了几道DP题，马上就先找有没有最优子结构来导出结果。&#160; &#160; &#160; &#160;但是仔细想了想，找不到什么最优子结构，浪费了不少时间，但是发现了一个规律，即对于任意i来说，以i为根节点构建一颗树，以i开头的任意子节点均满足递增或递减，就可以快速计算出总数目。如题例 [2,5,3,4,1]，可以构建2-&gt;3-&gt;4,5-&gt;3-&gt;1,5-&gt;4-&gt;1，这2棵树。其中保存的就是结果，对于深度为3的来说，满足的结果数就是1，对于深度为4来说，满足的结果数就是4，对于深度为5来说的树，满足的结果数就是10，规律也比较简单，深度每加1，增加的结果数就是排列组合求的Cn-1 2，比如深度3为结果1，深度4=1+C3 2=4，深度5=4+C4 2=10。根据这种方法，对数组进行遍历并且构建一颗树，然后进行BFS查看深度进行计算就可以了。并且这种方法是会保留结果的方法。 查看别人分享的思路&#160; &#160; &#160; &#160;虽然有了解法，但是毕竟一开始初衷还是贪心或者DP，还是不甘心，于是看了一下别人分享的题解，确实有比较取巧的解法，是我一开始的思路错了，这种思路简而言之就是对于任意一个i，把他当做中间数，求得左侧小于i的数的个数left_small，左侧大于i的数的个数left_big，右侧小于i的数的个数right_small，右侧大于i的数的个数right_big，此时就有以i为中间数的结果=left_smallright_big+left_bigright_small，这种思路实现简单，缺点是没有保存中间结果，最后上下代码 123456789101112131415161718192021222324252627func numTeams(rating []int) int &#123; ans:=0 for i:=0;i&lt;len(rating);i++&#123; left_big:=0 right_big:=0 left_small:=0 right_small:=0 for j:=i-1;j&gt;=0;j--&#123; if rating[j]&gt;rating[i] &#123; left_big++ &#125; if rating[j]&lt;rating[i]&#123; left_small++ &#125; &#125; for k:=i+1;k&lt;len(rating);k++&#123; if rating[k]&gt;rating[i] &#123; right_big++ &#125; if rating[k]&lt;rating[i]&#123; right_small++ &#125; &#125; ans+=left_small*right_big+left_big*right_small &#125; return ans&#125; 总结&#160; &#160; &#160; &#160;最近刷LeetCode，水题太水，有手就行，还是要刷点稍微需要一些思考的题目，才能提升自己，以后尽量坚持3简单+1中等的进度。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编译期注解处理器详细使用方法]]></title>
    <url>%2F2020%2F03%2F09%2FJava%E7%BC%96%E8%AF%91%E6%9C%9F%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8%E8%AF%A6%E7%BB%86%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Java编译期注解处理器&#160; &#160; &#160; &#160;Java编译期注解处理器，Annotation Processing Tool，简称APT，是Java提供给开发者的用于在编译期对注解进行处理的一系列API，这类API的使用被广泛的用于各种框架，如dubbo,lombok等。&#160; &#160; &#160; &#160;Java的注解处理一般分为2种，最常见也是最显式化的就是Spring以及Spring Boot的注解实现了，在运行期容器启动时，根据注解扫描类，并加载到Spring容器中。而另一种就是本文主要介绍的注解处理，即编译期注解处理器，用于在编译期通过JDK提供的API，对Java文件编译前生成的Java语法树进行处理，实现想要的功能。&#160; &#160; &#160; &#160;前段公司要求将原有dubbo迁入spring cloud架构，理所当然的最简单的方式，就是将原有的dubboRpc服务类，外面封装一层controller，并且将调用改成feignClient，这样能短时间的兼容原有其他未升级云模块的dubbo调用，之前考虑过其他方案，比如spring cloud sidecar，但是出于运维组考虑，还是不建议每台机器多加一个服务，并且只是为了短时间过渡，没必要多加一个技术栈，所以考虑使用编译期处理器来快速生成类似的java代码，避免手动大量处理会产生操作失误。&#160; &#160; &#160; &#160;练手项目示例的git源码：https://github.com/IntoTw/mob 启用注解处理器&#160; &#160; &#160; &#160;增加这么一个类，实现AbstractProcessor的方法 123456789101112131415161718192021222324252627282930313233343536//注解处理器会扫描的包名@SupportedAnnotationTypes("cn.intotw.*")@SupportedSourceVersion(SourceVersion.RELEASE_8)public class ModCloudAnnotationProcessor extends AbstractProcessor &#123; private Messager messager; private JavacTrees trees; private TreeMaker treeMaker; private Names names; Map&lt;String, JCTree.JCAssign&gt; consumerSourceAnnotationValue=new HashMap&lt;&gt;(); Map&lt;String, JCTree.JCAssign&gt; providerSourceAnnotationValue=new HashMap&lt;&gt;(); java.util.List&lt;String&gt; javaBaseVarType; @Override public void init(ProcessingEnvironment processingEnv) &#123; //基本构建，主要是初始化一些操作语法树需要的对象 super.init(processingEnv); this.messager = processingEnv.getMessager(); this.trees = JavacTrees.instance(processingEnv); Context context = ((JavacProcessingEnvironment) processingEnv).getContext(); this.treeMaker = TreeMaker.instance(context); this.names = Names.instance(context); &#125; @Override public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123; if (roundEnv.processingOver()) &#123; return false; &#125; //获取所有增加了自定义注解的element集合 Set&lt;? extends Element&gt; set = roundEnv.getElementsAnnotatedWith(MobCloudConsumer.class); //遍历这个集合，这个集合的每个element相当于一个拥有自定义注解的需要处理的类。 set.forEach(element -&gt; &#123; //获取语法树 JCTree jcTree=trees.getTree(element); printLog("result :&#123;&#125;",jcTree); &#125;); return true; &#125; &#160; &#160; &#160; &#160;上面代码中获取的jctree就是那个class文件解析后的java语法树了，下面来看下有哪些操作。 遍历语法树&#160; &#160; &#160; &#160;java语法树的遍历，并不是能像寻常树节点一样提供child之类的节点，而是通过TreeTranslator这个访问类的实现来做到的，这个类的可供实现的方法有很多，可以用来遍历语法树的注解、方法、变量，基本上语法树的所有java元素，都可以使用这个访问器来访问 123456789101112131415161718//获取源注解的参数jcTree.accept(new TreeTranslator()&#123; @Override public void visitAnnotation(JCTree.JCAnnotation jcAnnotation) &#123; JCTree.JCIdent jcIdent=(JCTree.JCIdent)jcAnnotation.getAnnotationType(); if(jcIdent.name.contentEquals("MobCloudConsumer"))&#123; printLog("class Annotation arg process:&#123;&#125;",jcAnnotation.toString()); jcAnnotation.args.forEach(e-&gt;&#123; JCTree.JCAssign jcAssign=(JCTree.JCAssign)e ; JCTree.JCIdent value = treeMaker.Ident(names.fromString("value")); JCTree.JCAssign targetArg=treeMaker.Assign(value,jcAssign.rhs); consumerSourceAnnotationValue.put(jcAssign.lhs.toString(),targetArg); &#125;); &#125; printLog("获取参数如下:",consumerSourceAnnotationValue); super.visitAnnotation(jcAnnotation); &#125;&#125;); 语法树中的源节点&#160; &#160; &#160; &#160;前面说了语法树是有一个个对象组成的，这些对象构成了语法树的一个个源节点，源节点对应java语法中核心的那些语法：| 语法树节点类 | 具体对应的语法元素 || — | — || JCClassDecl | 类的定义 || JCMethodDecl | 方法的定义 || JCAssign | 等式（赋值）语句 || JCExpression | 表达式 || JCAnnotation | 注解 || JCVariableDecl | 变量定义 | 语法树节点的操作&#160; &#160; &#160; &#160;既然说了语法树的那些重要节点，后面直接上案例，该如何操作。需要注意的一点是，Java语法树中所有的操作，对于语法树节点，都不能通过引用操作来复制，必须要从头到尾构造一个一模一样的对象并插入，否则编译是过不去的。 给类增加注解1234567891011121314151617181920212223242526272829303132333435//该方法最后会给类新增一个@FeignClient(value="")的注解private void addClassAnnotation(Element element) &#123; JCTree jcTree = trees.getTree(element); jcTree.accept(new TreeTranslator()&#123; //遍历所有类定义 @Override public void visitClassDef(JCTree.JCClassDecl jcClassDecl) &#123; JCTree.JCExpression arg; //创建一个value的赋值语句，作为注解的参数 if(jcAssigns==null || jcAssigns.size()==0)&#123; arg=makeArg("value",""); &#125; printLog("jcAssigns :&#123;&#125;",jcAssigns); //创建注解对象 JCTree.JCAnnotation jcAnnotation=makeAnnotation(PackageSupportEnum.FeignClient.toString(),List.of(arg)); printLog("class Annotation add:&#123;&#125;",jcAnnotation.toString()); //在原有类定义中append新的注解对象 jcClassDecl.mods.annotations=jcClassDecl.mods.annotations.append(jcAnnotation); jcClassDecl.mods.annotations.forEach(e -&gt; &#123; printLog("class Annotation list:&#123;&#125;",e.toString()); &#125;); super.visitClassDef(jcClassDecl); &#125; &#125;);&#125;public JCTree.JCExpression makeArg(String key,String value)&#123; //注解需要的参数是表达式，这里的实际实现为等式对象，Ident是值，Literal是value，最后结果为a=b JCTree.JCExpression arg = treeMaker.Assign(treeMaker.Ident(names.fromString(key)), treeMaker.Literal(value)); return arg;&#125;private JCTree.JCAnnotation makeAnnotation(String annotaionName, List&lt;JCTree.JCExpression&gt; args)&#123; JCTree.JCExpression expression=chainDots(annotaionName.split("\\.")); JCTree.JCAnnotation jcAnnotation=treeMaker.Annotation(expression, args); return jcAnnotation;&#125; 给类增加import语句12345678910111213141516171819202122232425262728293031323334353637383940414243private void addImport(Element element,PackageSupportEnum... packageSupportEnums) &#123; TreePath treePath = trees.getPath(element); JCTree.JCCompilationUnit jccu = (JCTree.JCCompilationUnit) treePath.getCompilationUnit(); java.util.List&lt;JCTree&gt; trees = new ArrayList&lt;&gt;(); trees.addAll(jccu.defs); java.util.List&lt;JCTree&gt; sourceImportList = new ArrayList&lt;&gt;(); trees.forEach(e-&gt;&#123; if(e.getKind().equals(Tree.Kind.IMPORT))&#123; sourceImportList.add(e); &#125; &#125;); java.util.List&lt;JCTree.JCImport&gt; needImportList=buildImportList(packageSupportEnums); for (int i = 0; i &lt; needImportList.size(); i++) &#123; boolean importExist=false; for (int j = 0; j &lt; sourceImportList.size(); j++) &#123; if(sourceImportList.get(j).toString().equals(needImportList.get(i).toString()))&#123; importExist=true; &#125; &#125; if(!importExist)&#123; trees.add(0,needImportList.get(i)); &#125; &#125; printLog("import trees&#123;&#125;",trees.toString()); jccu.defs=List.from(trees);&#125;private java.util.List&lt;JCTree.JCImport&gt; buildImportList(PackageSupportEnum... packageSupportEnums) &#123; java.util.List&lt;JCTree.JCImport&gt; targetImportList =new ArrayList&lt;&gt;(); if(packageSupportEnums.length&gt;0)&#123; for (int i = 0; i &lt; packageSupportEnums.length; i++) &#123; JCTree.JCImport needImport = buildImport(packageSupportEnums[i].getPackageName(),packageSupportEnums[i].getClassName()); targetImportList.add(needImport); &#125; &#125; return targetImportList;&#125;private JCTree.JCImport buildImport(String packageName, String className) &#123; JCTree.JCIdent ident = treeMaker.Ident(names.fromString(packageName)); JCTree.JCImport jcImport = treeMaker.Import(treeMaker.Select( ident, names.fromString(className)), false); printLog("add Import:&#123;&#125;",jcImport.toString()); return jcImport;&#125; 构建一个内部类&#160; &#160; &#160; &#160;这边演示了一个构建内部类的过程，基本就演示了深拷贝一个内部类的过程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131private JCTree.JCClassDecl buildInnerClass(JCTree.JCClassDecl sourceClassDecl, java.util.List&lt;JCTree.JCMethodDecl&gt; methodDecls) &#123; java.util.List&lt;JCTree.JCVariableDecl&gt; jcVariableDeclList = buildInnerClassVar(sourceClassDecl); String lowerClassName=sourceClassDecl.getSimpleName().toString(); lowerClassName=lowerClassName.substring(0,1).toLowerCase().concat(lowerClassName.substring(1)); java.util.List&lt;JCTree.JCMethodDecl&gt; jcMethodDecls = buildInnerClassMethods(methodDecls, lowerClassName); java.util.List&lt;JCTree&gt; jcTrees=new ArrayList&lt;&gt;(); jcTrees.addAll(jcVariableDeclList); jcTrees.addAll(jcMethodDecls); JCTree.JCClassDecl targetClassDecl = treeMaker.ClassDef( buildInnerClassAnnotation(), names.fromString(sourceClassDecl.name.toString().concat("InnerController")), List.nil(), null, List.nil(), List.from(jcTrees)); return targetClassDecl;&#125;private java.util.List&lt;JCTree.JCVariableDecl&gt; buildInnerClassVar(JCTree.JCClassDecl jcClassDecl) &#123; String parentClassName=jcClassDecl.getSimpleName().toString(); printLog("simpleClassName:&#123;&#125;",parentClassName); java.util.List&lt;JCTree.JCVariableDecl&gt; jcVariableDeclList=new ArrayList&lt;&gt;(); java.util.List&lt;JCTree.JCAnnotation&gt; jcAnnotations=new ArrayList&lt;&gt;(); JCTree.JCAnnotation jcAnnotation=makeAnnotation(PackageSupportEnum.Autowired.toString() ,List.nil()); jcAnnotations.add(jcAnnotation); JCTree.JCVariableDecl jcVariableDecl = treeMaker.VarDef(treeMaker.Modifiers(1, from(jcAnnotations)), names.fromString(parentClassName.substring(0, 1).toLowerCase().concat(parentClassName.substring(1))), treeMaker.Ident(names.fromString(parentClassName)), null); jcVariableDeclList.add(jcVariableDecl); return jcVariableDeclList;&#125;private JCTree.JCModifiers buildInnerClassAnnotation() &#123; JCTree.JCExpression jcAssign=makeArg("value",providerSourceAnnotationValue.get("feignClientPrefix").rhs.toString().replace("\"","")); JCTree.JCAnnotation jcAnnotation=makeAnnotation(PackageSupportEnum.RequestMapping.toString(), List.of(jcAssign) ); JCTree.JCAnnotation restController=makeAnnotation(PackageSupportEnum.RestController.toString(),List.nil()); JCTree.JCModifiers mods=treeMaker.Modifiers(Flags.PUBLIC|Flags.STATIC,List.of(jcAnnotation).append(restController)); return mods;&#125;//深度拷贝内部类方法private java.util.List&lt;JCTree.JCMethodDecl&gt; buildInnerClassMethods(java.util.List&lt;JCTree.JCMethodDecl&gt; methodDecls,String serviceName) &#123; java.util.List&lt;JCTree.JCMethodDecl&gt; target = new ArrayList&lt;&gt;(); methodDecls.forEach(e -&gt; &#123; if (!e.name.contentEquals("&lt;init&gt;")) &#123; java.util.List&lt;JCTree.JCVariableDecl&gt; targetParams=new ArrayList&lt;&gt;(); e.params.forEach(param-&gt;&#123; JCTree.JCVariableDecl newParam=treeMaker.VarDef( (JCTree.JCModifiers) param.mods.clone(), param.name, param.vartype, param.init ); printLog("copy of param:&#123;&#125;",newParam); targetParams.add(newParam); &#125;); JCTree.JCMethodDecl methodDecl = treeMaker.MethodDef( (JCTree.JCModifiers) e.mods.clone(), e.name, (JCTree.JCExpression) e.restype.clone(), e.typarams, e.recvparam, List.from(targetParams), e.thrown, treeMaker.Block(0L,List.nil()), e.defaultValue ); target.add(methodDecl); &#125; &#125;); target.forEach(e -&gt; &#123; if (e.params.size() &gt; 0) &#123; for (int i = 0; i &lt; e.params.size() ; i++) &#123; JCTree.JCVariableDecl jcVariableDecl=e.params.get(i); if(i==0)&#123; //第一个参数加requestbody注解，其他参数加requestparam注解，否则会报错 if(!isBaseVarType(jcVariableDecl.vartype.toString())) &#123; jcVariableDecl.mods.annotations = jcVariableDecl.mods.annotations.append(makeAnnotation(PackageSupportEnum.RequestBody.toString(), List.nil())); &#125;else &#123; JCTree.JCAnnotation requestParam=makeAnnotation(PackageSupportEnum.RequestParam.toString(), List.of(makeArg("value",jcVariableDecl.name.toString()))); jcVariableDecl.mods.annotations = jcVariableDecl.mods.annotations.append(requestParam); &#125; &#125;else &#123; JCTree.JCAnnotation requestParam=makeAnnotation(PackageSupportEnum.RequestParam.toString(), List.of(makeArg("value",jcVariableDecl.name.toString()))); jcVariableDecl.mods.annotations = jcVariableDecl.mods.annotations.append(requestParam); &#125; &#125; &#125; printLog("sourceMethods: &#123;&#125;", e); //value JCTree.JCExpression jcAssign=makeArg("value","/"+e.name.toString()); JCTree.JCAnnotation jcAnnotation = makeAnnotation( PackageSupportEnum.PostMapping.toString(), List.of(jcAssign) ); printLog("annotation: &#123;&#125;", jcAnnotation); e.mods.annotations = e.mods.annotations.append(jcAnnotation); JCTree.JCExpressionStatement exec = getMethodInvocationStat(serviceName, e.name.toString(), e.params); if(!e.restype.toString().contains("void"))&#123; JCTree.JCReturn jcReturn=treeMaker.Return(exec.getExpression()); e.body.stats = e.body.stats.append(jcReturn); &#125;else &#123; e.body.stats = e.body.stats.append(exec); &#125; &#125;); return List.from(target);&#125;//创建方法调用，如String.format()这种private JCTree.JCExpressionStatement getMethodInvocationStat(String invokeFrom, String invokeMethod, List&lt;JCTree.JCVariableDecl&gt; args) &#123; java.util.List&lt;JCTree.JCIdent&gt; params = new ArrayList&lt;&gt;(); args.forEach(e -&gt; &#123; params.add(treeMaker.Ident(e.name)); &#125;); JCTree.JCIdent invocationFrom = treeMaker.Ident(names.fromString(invokeFrom)); JCTree.JCFieldAccess jcFieldAccess1 = treeMaker.Select(invocationFrom, names.fromString(invokeMethod)); JCTree.JCMethodInvocation apply = treeMaker.Apply(nil(), jcFieldAccess1, List.from(params)); JCTree.JCExpressionStatement exec = treeMaker.Exec(apply); printLog("method invoke:&#123;&#125;", exec); return exec;&#125; 使用方法&#160; &#160; &#160; &#160;注解器的实际使用，需要在resource文件夹下的META-INF.services文件夹下，新建一个叫做javax.annotation.processing.Processor的文件，里面写上需要生效的类注解处理器的包名加类名，例如：cn.intotw.mob.ModCloudAnnotationProcessor。&#160; &#160; &#160; &#160;然后如果是作为第三方jar包提供给别人，需要在maven打包时增加如下配置，主要也是把javax.annotation.processing.Processor文件也打包到对应目录： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;excludes&gt; &lt;exclude&gt;META-INF/**/*&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;process-META&lt;/id&gt; &lt;phase&gt;prepare-package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;copy-resources&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;outputDirectory&gt;target/classes&lt;/outputDirectory&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;$&#123;basedir&#125;/src/main/resources/&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 总结&#160; &#160; &#160; &#160;这个技术主要也是以摸索API使用为主，国内没有什么资料，国外的资料也都是语法和类的介绍，实际例子并不多，花了很多时间摸索具体使用的方法，基本能达到实现一切操作了，毕竟注解，方法，类，变量，方法调用，这些都能自定义了，基本也没有什么别的了。期间参考了不少lombok的源码，lombok是在java语法树节点之外利用自己的语法树节点封装了一层，简化和规范了很多操作，可惜我找了一下lombok貌似并没有提供类似于工具包辅助，所以更加深入的使用推荐参考lombok源码的实现。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>编译期注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KeepAlive安装以及简单配置]]></title>
    <url>%2F2020%2F01%2F02%2FKeepAlive%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[操作系统：Centos7.3 一.依赖安装首先安装相关依赖： 123yum install -y gcc openssl-devel popt-develyum -y install libnl libnl-develyum install -y libnfnetlink-devel 基本依赖就安装完毕了，如果还缺少什么依赖在下一步编译的时候会有warning，百度去解决就好了 二.编译安装源码首先下载源码到指定目录: 12cd /usr/local/srcwget http://www.keepalived.org/software/keepalived-1.3.4.tar.gz 然后解压，配置 123tar zxvf keepalived-1.3.4.tar.gz cd keepalived-1.3.4./configure --prefix=/usr/local/keepalived 之后编译 12make make install 注意这一步make之后可能会有warning，一般都是缺少依赖造成的，把warning关键字百度一下去yum安装对应依赖就可以了 三.修改配置文件地址安装完成后，keepalived的默认配置文件地址和我们安装的地址不一样，所以cp过去就可以了 12345cp ../keepalived-1.3.4/keepalived/etc/init.d/keepalived /etc/init.d/mkdir /etc/keepalivedcp /usr/local/keepalived/etc/keepalived/keepalived.conf /etc/keepalived/cp keepalived-1.3.4/keepalived/etc/sysconfig/keepalived /etc/sysconfig/cp /usr/local/keepalived/sbin/keepalived /usr/sbin/ 之后只要修改/etc/keepalived/ 目录下的keepalived.conf配置文件就可以了 使用service start keepalived启动服务 四.附keepalived简单配置文件1234567891011121314151617181920! Configuration File for keepalivedglobal_defs &#123; router_id lb01 #设置本机路由id，做区分的&#125;vrrp_instance VI_1 &#123; state MASTER #主从标记，仅做标识 interface eth0 #虚拟路由的网卡名 virtual_router_id 51 #虚拟路由路由id，想要配置在同一个虚拟ip必须要有相同id priority 150 #优先级，优先级最高的自动为主机，主机宕机后按照优先级选择热备从机 advert_int 1 #主备通讯时间间隔 authentication &#123; auth_type PASS auth_pass 1111 &#125; virtual_ipaddress &#123; 172.17.0.199 #配置到哪个虚拟ip，这里我是在docker中，所以是这个docker的默认网段的一个ip，主备机这个地方ip要相同 &#125;&#125;]]></content>
      <categories>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
        <tag>运维相关</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xxl-job较深入使用]]></title>
    <url>%2F2019%2F12%2F31%2Fxxl-job%E8%BE%83%E6%B7%B1%E5%85%A5%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[&#160; &#160; &#160; &#160;xxl-job是一个分布式定时任务调度框架，功能强大，底层使用自己实现的rpc框架进行注册和管理，数据库使用mysql，调度触发使用数据库锁来作为调度锁。 &#160; &#160; &#160; &#160;xxl-job主要分为调度中心admin以及任务，任务引入依赖jar包并配置启动类为spring所管理的bean后，将自动通过spring-bean提供的initMethod进行启动线程选择一个端口进行注册以及监听任务调度。 &#160; &#160; &#160; &#160;公司目前引入xxl-job框架代替quartz框架作为分布式任务调度组件，并在其之上进行一定开发以及优化，所以这篇文章主要分享一些深入使用，主要是概念的详细介绍。 系统关键概念介绍执行器&#160; &#160; &#160; &#160;配置中心配置的执行器，概念上对应执行定时任务的服务，支持分布式调度以及调度的各种路由规则配置。注册方式支持自动注册和手动配置机器地址两种方式，心跳时间间隔默认为30s，失效时间90s。 &#160; &#160; &#160; &#160;执行器自动注册后，调度中心页面依旧有最长30秒的延迟显示，原因是数据库中注册表更新后，展示执行器的表是由另一个守护线程去更新的，更新频率为默认心跳时间30s，所以管理台展示会有延迟，但不影响任务调度。 任务&#160; &#160; &#160; &#160;任务以执行器为维度配置，每个任务必须属于一个执行器，当任务触发时会根据该任务所属的执行器去寻找执行器的地址列表，然后通过配置的路由规则以及阻塞规则去去执行。 &#160; &#160; &#160; &#160;任务支持本地任务以及远程任务，本地任务即按照执行方写好的业务逻辑执行。远程任务通过GLUE，在调度中心管理台写好代码，分发到执行方去执行。建议无特殊需求的话，统一使用本地任务。 任务配置项描述1. 执行器：选择该任务由哪个执行器去执行2. 任务描述：简单描述该任务的功能以及作用，如：码上行单边行程推送3. 路由策略：设置任务执行时，如何去选择执行器，高频任务建议使用一致性哈希或者第一台执行4. Cron：Cron表达式，描述任务运行的时间5. 运行模式：BEAN即为接入服务配置在本地对应的handler运行，其他方式均为管理台设置代码交由接入服务远程执行6. JobHandler：运行模式为BEAN时必填，值应当为接入服务本地执行任务的handler7. 阻塞策略：当同一任务多次调度到同一台执行器时，执行器应当使用的策略8. 子任务ID：如配置，则该任务完成后自动触发一次子任务的执行9. 任务超时时间：配置后当任务超时时将自动终止任务执行。10. 失败重试次数：任务失败后重试的次数。11. 负责人：一般为该任务接入方的负责人12. 报警邮件：任务报警后发送的邮件地址13. 任务参数：若配置了任务参数，任务调度时将发送任务参数至执行方handler。 阻塞策略&#160; &#160; &#160; &#160;阻塞策略即同一个任务在执行器的阻塞执行策略。由执行器端控制。典型场景为：任务A分发到执行器A执行，此时任务A再次触发并分发到执行器A，此时根据阻塞策略选择的不同将会有以下三种执行策略：1. 单机串行 该策略下，同一执行器收到同一任务的调度触发时，若已有任务正在执行，会将后续的任务放入执行线程的队列中，等待线程轮询继续执行，可能会导致线程队列阻塞过多任务导致内存过高，高频且耗时较长任务慎用。 2. 丢弃后续调度 该策略下，同一执行器收到同一任务的调度触发时，若已有任务正在执行，会直接丢弃后续同一任务的调度，推荐使用。 3. 3. 覆盖之前调度 该策略下，同一执行器收到同一任务的调度触发时，若已有任务正在执行，将会直接停止正在执行的任务（通过线程InterruptedException异常以及volatile变量判断），并将新任务放入队列。一般情况下不建议使用。 路由策略&#160; &#160; &#160; &#160;路由策略即任务在配置中心进行调度分发时，选择执行器的策略。由配置中心端控制。典型场景为：任务A触发执行，任务A对应的执行器有执行器A，B，C，D，此时根据路由策略的选择将会有以下几种分发情况1. 第一个：始终选择第一台执行器作为任务执行器，不论该任务执行器是否正常。2. 最后一个：始终选择最后一台作为任务执行器3. 轮询：每个执行器轮流执行4. 随机：随机选择一个执行器执行5. 一致性HASH：根据任务ID做一致性哈希选择执行器，同一个任务必定只分发到同一个执行器。高频或耗时较长任务推荐使用6. 最不经常使用：选择平均使用频率最低的执行器。7. 最近最久未使用：选择最近的最久未使用的执行器。8. 故障转移：分别进行心跳检测，选择第一台心跳检测正常的机器执行。9. 忙碌转移：分别进行忙碌检测，选择第一台空闲的机器执行。10. 分片广播：广播到所有执行器执行，并提供分片参数，分片参数获取方式如下，应用在被触发时动态获取自己是第几个分片，共有几个分片： 日志问题&#160; &#160; &#160; &#160;xxl-job相关日志使用默认使用slf4j作为日志框架，使用专门的API写入日志时，会输出2种日志，客户端日志与服务端日志 客户端日志&#160; &#160; &#160; &#160;客户端日志根据配置文件中配置的logpath指定，根据源码分析，客户端日志将通过FileOutputStream写到对应文件，且无法通过配置修改，所以只好修改了源码中的逻辑，改为该值为空未配置时，直接通过slf4j写入。 服务端日志&#160; &#160; &#160; &#160;使用xxljob的日志api输出日志时，日志也会在调度管理台看到，能看到的原理是xxl-job管理台会通过rpc调用执行器的接口，执行器收到请求后从指定的日志文件中读取执行的日志并返回，这里存在一个比较麻烦的问题，就是xxl-job这种日志的逻辑，无法很好的兼容到项目统一的日志模块里，十分不便。 &#160; &#160; &#160; &#160;所以实际使用过程中，我们在xxl-job管理台查询日志时，对其进行了改造，修改为不从rpc查询，而是走我们日志管理的搜索引擎根据执行的jobid查询相关日志，结合客户端日志输出的改造，从而统一xxl-job和我们系统间的日志管理。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>xxl-job</tag>
        <tag>定时任务调度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot WebSocket技术]]></title>
    <url>%2F2019%2F12%2F31%2FSpring%20Boot%20WebSocket%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[最近看了Spring in Action，了解了一下WebSocket和Stomp协议相关技术，并搭建了一个项目。网上的例子不完整或者描述不清，所以自己记录一下以作备忘。 一.配置&#160; &#160; &#160; &#160;Spring Boot项目搭建完成后，基于Spring Boot一切皆配置的概念，添加WebSocket支持十分简单。 &#160; &#160; &#160; &#160;首先是maven依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;&lt;/dependency&gt; &#160; &#160; &#160; &#160;如果是使用的Spring Mvc的话，可能需要添加另外的2个依赖。 &#160; &#160; &#160; &#160;然后是添加配置类：WebSocketConfig 12345678910111213141516171819import org.springframework.context.annotation.Configuration;import org.springframework.messaging.simp.config.MessageBrokerRegistry;import org.springframework.web.socket.config.annotation.AbstractWebSocketMessageBrokerConfigurer;import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;import org.springframework.web.socket.config.annotation.StompEndpointRegistry;@Configuration@EnableWebSocketMessageBrokerpublic class WebSocketConfig extends AbstractWebSocketMessageBrokerConfigurer &#123; @Override public void registerStompEndpoints(StompEndpointRegistry stompEndpointRegistry) &#123; stompEndpointRegistry.addEndpoint("/endpointSang").withSockJS(); &#125; @Override public void configureMessageBroker(MessageBrokerRegistry registry) &#123; registry.enableSimpleBroker("/happy"); &#125;&#125; 其中的两个路径：1.addEndpoint添加的第一个路径，是监听WebSocket连接的Stomp代理的端点，页面请求WebSocket连接时，连接到注册的该端点上Stomp代理，之后的消息会交给Stomp代理处理。 2.该配置启用了一个简单的消息代理，用来处理前缀为/happy的消息，也就是说，只有路径为/happy请求时，消息才会由消息代理处理 二.后端配置控制器ControllerController十分相似，部分注解略有不同: 123456789101112131415161718192021222324252627282930import com.example.demo.bean.TestMessage;import com.example.demo.bean.TestResponse;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.messaging.handler.annotation.MessageMapping;import org.springframework.messaging.handler.annotation.SendTo;import org.springframework.messaging.simp.SimpMessagingTemplate;import org.springframework.stereotype.Controller;import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Date;@Controllerpublic class WsController &#123; @Autowired private SimpMessagingTemplate messagingTemplate; @MessageMapping("/welcome")//接收路径 @SendTo("/happy/getNewResponse")//消息返回到的路径 public TestResponse say(TestMessage message) &#123; System.out.println(message.getName()); say1();//调用另外的方式返回（由服务器主动发起的返回） return new TestResponse("welcome," + message.getName() + " !");//这次同步通信的返回 &#125; public void say1() &#123; Date date =new Date(System.currentTimeMillis()); DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); System.out.println(date); messagingTemplate.convertAndSend("/happy/getHappyResponse", df.format(new Date()));//设置路径以及内容，返回当前服务器时间 &#125;&#125; TestMessage与TestResponse为普通JavaBean，消息转换机制等与普通Controller基本一致 SimpMessagingTemplate该类提供为主动向页面正在监听WebSocket的程序发送消息的功能 @MessageMapping注解，与@RequestMapping注解类似，配置后台接收消息的路径以及处理函数 @SendTo注解，一般与@MessageMapping注解一起使用，该注解配置的控制器，返回的数据将发送到监听该配置路径的监听函数 三.前端页面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"/&gt; &lt;title&gt;广播式WebSocket&lt;/title&gt; &lt;script src="../static/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="../static/stomp.js"&gt;&lt;/script&gt; &lt;script src="../static/sockjs.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body onload="disconnect()"&gt;&lt;div&gt; &lt;div&gt; &lt;button id="connect" onclick="connect();"&gt;连接&lt;/button&gt; &lt;button id="disconnect" disabled="disabled" onclick="disconnect();"&gt;断开连接&lt;/button&gt; &lt;/div&gt; &lt;div id="conversationDiv"&gt; &lt;label&gt;输入你的名字&lt;/label&gt;&lt;input type="text" id="name"/&gt; &lt;button id="sendName" onclick="sendName();"&gt;发送&lt;/button&gt; &lt;p id="response"&gt;&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var stompClient = null; function setConnected(connected) &#123; document.getElementById("connect").disabled = connected; document.getElementById("disconnect").disabled = !connected; document.getElementById("conversationDiv").style.visibility = connected ? 'visible' : 'hidden'; $("#response").html(); &#125; function connect() &#123; var socket = new SockJS('/endpointSang');//通过先前配置的端点建立连接 stompClient = Stomp.over(socket); stompClient.connect(&#123;&#125;, function (frame) &#123; setConnected(true); console.log('Connected:' + frame); //开启监听，监听服务器推送到路径/happy/getNewResponse stompClient.subscribe('/happy/getNewResponse', function (response) &#123; alert(JSON.parse(response.body).responseMessage); &#125;); //开启监听，监听服务器推送到路径/happy/getHappyResponse stompClient.subscribe('/happy/getHappyResponse', function (response) &#123; console.log(response.body); &#125;) &#125;); &#125; //关闭连接 function disconnect() &#123; if (stompClient != null) &#123; stompClient.disconnect(); &#125; setConnected(false); console.log('Disconnected'); &#125; //主动发送信息 function sendName() &#123; var name = $('#name').val(); console.log('name:' + name); //发送信息到后台监听/welcome路径的controller stompClient.send("/welcome", &#123;&#125;, JSON.stringify(&#123;'name': name&#125;)); &#125; function showResponse(message) &#123; $("#response").html(message); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 运行结果控制台日志： 注：广播模式，只要所有程序监听同一个后台广播路径就可以了点对点通信模式，可以在Js端使用随机数或者根据TokenId开启监听路径，后台根据用户的TokenId派发到不同端点就可以了]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot Scheduled定时任务特性]]></title>
    <url>%2F2019%2F07%2F03%2FSpring-Boot-Scheduled%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[&#160; &#160; &#160; &#160;SpringBoot中的Scheduled定时任务是Spring Boot中非常常用的特性，用来执行一些比如日切或者日终对账这种定时任务 &#160; &#160; &#160; &#160;下面说说使用时要注意的Scheduled的几个特性 Scheduled的执行方式&#160; &#160; &#160; &#160;Scheduled按照顺序执行，对于某个task未做配置的话只会起一个线程去执行，也就是说当你某个任务在处理中阻塞了，哪怕轮询时间再次到达，Spring也不会再起线程执行该任务，而是会等待上次任务执行完毕，所以请不要在Scheduled的task中做一些比较需要频繁触发的易失败，易阻塞，易超时操作，避免任务无法正常轮询执行 Scheduled中的线程池&#160; &#160; &#160; &#160;Scheduled执行可以通过Spring Boot提供的配置来配置定时任务执行的线程池等信息，如果未做配置的话，根据我测试，所有定时任务仅有一个线程去执行，也就是说如果某个task阻塞，其他task都将得不到执行。具体配置方法如下 @Configuration @EnableScheduling public class SchedulerTaskConfiguration implements SchedulingConfigurer { @Override public void configureTasks(ScheduledTaskRegistrar scheduledTaskRegistrar) { scheduledTaskRegistrar.setScheduler(taskExecutor()); } @Bean public Executor taskExecutor() { //线程池大小 return Executors.newScheduledThreadPool(10); } }&#160; &#160; &#160; &#160;但是哪怕是配置了线程池，也只是降低了多个task之间执行的影响，对于单个task来说，哪怕配置了线程池，依旧会因为上次执行的阻塞影响到下一次触发 Scheduled的执行频率&#160; &#160; &#160; &#160;Scheduled的执行频率可以由2种方式控制，一种为在@Scheduled中添加fixedRate属性，即@Scheduled(fixedRate = 10)，数字为执行的间隔毫秒，也就是多少毫秒执行一次 &#160; &#160; &#160; &#160;另一种为添加cron属性，属性值为cron表达式，可以通过cron表达式指定为具体某年某月某分某秒，也可以通过cron表达式指定为间隔几小时或几分钟执行一次,如@Scheduled(cron = “0 0 1 * * *”)]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Scheduled</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不继续使用CSDN的原因]]></title>
    <url>%2F2019%2F06%2F27%2F%E4%B8%8D%E7%BB%A7%E7%BB%AD%E4%BD%BF%E7%94%A8CSDN%E7%9A%84%E5%8E%9F%E5%9B%A0%2F</url>
    <content type="text"><![CDATA[&#160; &#160; &#160; &#160;一直了解到很多人选择Hexo搭建自己的博客，本来想在自己云服务器上搭一个的，后面了解到Github可以通过静态资源的映射免费搞，还挺方便的，但是因为懒，一直就在CSDN写写，毕竟从大学开始就在CSDN上各种查资料和学习。 &#160; &#160; &#160; &#160;或许什么事都会变质吧，最近在某度查一个DB2的问题，发现置顶的2条竟然就是CSDN的内容，但是点进去竟然是类似于站内搜索的页面，只列出了一些内容相关的，但是在某度的页面上显示确实关键字完全匹配，这顿时让我觉得十分恶心。 &#160; &#160; &#160; &#160;所以抽空自己搞了下Hexo，不过有点想吐槽下，基本就是照着别人的教程弄，这东西想搞明白还是得NodeJs和前端都比较了解的人才能看懂或者定制化，有点伤。 &#160; &#160; &#160; &#160;不过一顿操作后，写写文章是没什么问题了，以后就在这里写吧。 &#160; &#160; &#160; &#160;就这样。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git使用详解]]></title>
    <url>%2F2019%2F06%2F27%2FGit%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[&#160; &#160; &#160; &#160;之前公司要做技术分享，因为Git虽然看似简单，但是实际上是使用较多而且较为重要的一个工具，所以做了一下大概的总结。 &#160; &#160; &#160; &#160;因为新来的同事问了一个问题，紧急版本要拉hotfix分支修改，但是hotfix分支如何优雅的合并到各个分支上去呢？尤其是hotfix修改的位置比较敏感的情况下。 所以顺带也研究了一下这个问题 &#160; &#160; &#160; &#160;下面根据Git最关键的几个概念，穿插了Git几个命令实际做了什么 版本号&#160; &#160; &#160; &#160;Git本身有版本号的概念，版本号基于每次commit，查看最近的commit可以使用git log查看，查看所有历史版本可以使用git reflog查看所有本地commit的版本号，使用这两个命令可以查看到commit过的记录和commit时填写的信息，但是命令行内查看好像暂时不支持中文的commit信息显示。 仓库&#160; &#160; &#160; &#160;Git有2个仓库概念，一个是远端仓库，一个是本地仓库。在本地和远端之间同步的时候一定要谨慎 本地仓库&#160; &#160; &#160; &#160;实际上，在不使用fetch，pull，push，merge这几个命令的情况下，Git是仅使用本地仓库就可以完成版本管理的，主要的命令（或者说是操作）涉及到add，commit。 add操作用于将目录下的文件添加到Git的工作空间里去，同目录下未使用add命令添加过的文件，是不参与到git版本管理中去的，也就是说是独立于Git的。 commit操作用于提交修改，仅限于本地，用于提交每次修改，commit会产生一个commit id，这个id标识这次commit，在本地的话，实际上版本管理就是不断基于commit做的版本管理，假设commit过3次内容为A,B,C。C为最后commit的版本，此时想回退，只需要git reset commitid –hard 命令，就能把本地仓库回退到B或A的那次commit。 revert用于在某次commit之后，假设commit id为A，此时做了一系列修改，但未commit，此时revert会将所有修改取消，回归到commit id为A时的状态。 远程仓库&#160; &#160; &#160; &#160;实际上，远程仓库仅仅可以看做是一个代码的备份，是一个公共的备份，也就是说，在每次push后，你的本地仓库和远程仓库所有文件应该是一模一样的，通过push的话，会把本地的所有commit同步到远程仓库上去，也就是说，远程仓库的commit过程应该是每个人在本地commit的总和，但可能顺序不同。 &#160; &#160; &#160; &#160;对本地仓库来说，pull就等于同步远端仓库到本地仓库加merge，push就等于把本地仓库同步到远端仓库加merge。 &#160; &#160; &#160; &#160;Merge的本质，是将两个分支同步，实际上都是在本地merge。说一下这个过程，假设现在远端仓库版本为A，此时小g和小w同时从A上pull到了本地仓库将他们自己的本地仓库同步到了远端的版本A，此时他们的本地仓库我们假设为A1，A2，他们基于A1,A2做了自己的修改，并且同时修改了test.txt，然后都想提交到远端，第一个提交的人肯定可以提交成功，但是第二个提交的人必定会出现push失败，需要merge该文件，此时他在idea中merge了该文件确认自己改的才是对的，然后再push，此时就成功了。 &#160; &#160; &#160; &#160;解释一下，此时的merge实际过程是他处理了冲突之后，又进行了一次针对merge的commit，此次commit专门用来处理冲突并提交，具体体现在idea里你会发现，有的时候会让你选accept theirs,accept yours，你选了accept yours或者全部按照你本地来作为最终版本的文件，不需要commit，如果你选的是accept theirs或者merge的时候选择了远端的修改，那么你本地需要全部commit一次再提交，也就是说实际处理的merge是在本地确认了merge结果，这次commit和push实际idea是做了特殊处理的，带着merge的头，所以可以不会再次触发冲突，idea直接通过强制-force push到远端。 Bug修改，Hotfix&#160; &#160; &#160; &#160;之前考虑到生产环境修改，紧急bug修复，会基于生产环境分支创建一个hotfix分支，做修改完成后由prod分支合并hotfix分支，然后删除hotfix分支，但是这带来了一个问题，该hotfix分支难以合并到例如dev，test等分支，因为： 1.配置文件问题，从hotfix分支merge到dev分支，会导致dev等分支配置文件被覆盖，十分麻烦 2.版本管理问题，如果dev此时分支远远超前prod分支，那么此时将不可能合并hotfix的修改到dev上 可以通过git的stash功能解决这个问题。 &#160; &#160; &#160; &#160;stash和他的操作unstash的本质，是创建一个修改副本。他的应用场景和操作模式在于，有的时候本地做了一系列修改，但是忽然又要全部回到修改前的时候进行一下打包，此时要么从新从远端拉一个分支到本地，要么就直接copy一份项目到其他目录，然后这个目录下的revert掉，改完覆盖回来。 &#160; &#160; &#160; &#160;stash可以轻松解决，stash可以对当前所有的修改（具体提现到所有蓝色的文件）做一个备份，创建一个stash后，项目会自动回到当前commit id的状态（相当于revert），相当于对所有修改做了一个另外的保存，然后可以通过unstash可以把这些修改还原回来。 &#160; &#160; &#160; &#160;这样的话通过这个功能可以很轻松的解决这个问题，本地check出来hotfix分支之后，修改完毕不要先commit，先进行stash，然后unstash回来，再进行commit，push。完成后回到dev分支进行unstash同样进行一下更改，就把更改应用在dev分支上了。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
